Objetivos gerais:
    Adicionar suporte ao redimensionamento dinâmico
        Capacidade de expandir o seu tamanho automaticamente
        Capacidade de reduzir o seu tamanho automaticamente

Objetivos específicos:
    Capacidade inicial: 50 elementos
    Se num_elem = capacidade => dobrar a capacidade
    Se num_elem <= 0.25 * capacidade => reduzir pela metade a capacidade

Dica:
    Utilizar a função realloc para redimensionar o vetor de forma dinâmica,
    alterando sua capacidade para o novo tamanho desejado sem perder os dados
    já armazenados.

Instrução:
    Criar uma função resize que aumente e reduza o tamanho

Meu plano:
para expandir => checar as condições nos métodos de inserção (no início)

para reduzir => checar as condições nos métodos de exclusão (ao final)  


Mudanças:
1) Ajustar a declaração da estrutura LISTA para que o array A seja um ponteiro dinâmico
    typedef struct {
        REGISTRO* A;  // Ponteiro para o array dinâmico
        int nroElem;  // Número de elementos atualmente armazenados
    } LISTA;

2) Inserir o campo maxLista na estrutura da lista para monitorar o número máximo
de elementos da lista (que mudará dinamicamente), pois a constante MAX definida
em #define MAX 50 não pode ser mudada.
    typedef struct {
        REGISTRO* A;  // Ponteiro para o array dinâmico
        int nroElem;  // Número de elementos atualmente armazenados
        int maxLista; // Capacidade máxima da lista
    } LISTA;

3) Atualizar a função de inicialização da lista:
Aloca dinamicamente para os registros
Adicionei a redefinição da variável maxLista para o valor MAX proposto inialmente
    void inicializarLista(LISTA* l) {
    //malloc(MAX + 1): inclui o registro sentinela
        l->A = (REGISTRO*)malloc((MAX + 1) * sizeof(REGISTRO));
        if (l->A == NULL) {
            printf("Erro ao alocar memória.\n");
            exit(1);
        }
        l->nroElem = 0;
        l->maxLista = MAX;
    }

3) Atualizar a função tamanhoEmBytes, pois agora a função como estava
só retornaria o tamanho do ponteiro REGISTRO (e não o tamanho do array)
    int tamanhoEmBytes(LISTA* l) {
        return sizeof(LISTA) + ((l->maxLista + 1) * sizeof(REGISTRO));
    }   

4) Criar uma função para exibir a capacidade máxima da lista em elementos
(não leva em conta o sentinela)
    int tamanhoEmElementos(LISTA* l){
    return l->maxLista;
    }

5) Criar uma função para calcular o tamanho do array registro em bytes
necessários para conter x elementos. Esse valor será usado na função de
redimensionamento
int calculaTamanhoEmBytes(int nroElem) {
        //+1 => considerar o sentinela
        return (nroElem + 1) * sizeof(REGISTRO);
}

6) Criar a função resize para o redimensionamento da lista. Ela recebe
um argumento inteiro. Se for 1, ocorrerá duplicação de sua capacidade.
Caso o valor seja -1, terá sua capacidade reduzida pela metade.
O controle do número de elementos e do argumento a ser passado fica para
a função que a chamar;
    void resize(LISTA* l, int operacao) {
        if (operacao == 1) { // Operação para aumentar a capacidade
            int novoTamanhoElem = 2 * l->maxLista; // Dobrar a capacidade
            REGISTRO* novoArray = (REGISTRO*)realloc(l->A, (novoTamanhoElem + 1) * sizeof(REGISTRO));
            if (novoArray == NULL) {
                printf("Erro ao redimensionar o array.\n");
                return;
            }
            l->A = novoArray;        // Atualiza o ponteiro para o novo array
            l->maxLista = novoTamanhoElem; // Atualiza a capacidade máxima
        } else if (operacao == -1){
            int novoTamanhoElem = l->maxLista / 2; // Reduz em capacidade pela metade
            REGISTRO* novoArray = (REGISTRO*)realloc(l->A, (novoTamanhoElem + 1) * sizeof(REGISTRO));
            if (novoArray == NULL) {
                printf("Erro ao redimensionar o array.\n");
                return;
            }
            l->A = novoArray;        // Atualiza o ponteiro para o novo array
            l->maxLista = novoTamanhoElem; // Atualiza a capacidade máxima
        } else {
        printf("Operação inválida. Use 1 para aumentar ou -1 para reduzir a capacidade.\n");
        }
    }

7) Atualizada a ação condicional nas funções de inserção
No lugar de:
    if(l->nroElem >= MAX) return false; // lista cheia
Colacado:
    if(l->nroElem >= l->maxLista) resize (l,1); /*chama a função de redimensionamento
  com o parâmetro 1 (duplicação) */
Agora, sempre que atingir a capacidade máxima, ocorre o redimensionamento automático
para o dobro da capacidade (primeiro objetivo específicos - aumentar capacidade)






4) Criar uma função para calcular o tamanho da lista em bytes necessários
para conter x elementos. Esse valor será usado na função de redimensionamento

    int calculaTamanhoEmBytes(int nroElem) {
        //+1 => considerar o sentinela
        int bytesRegistro = (nroElem + 1) * sizeof(REGISTRO);
        int bytesNroElem = sizeof(int);
        int bytesMaxLista = sizeof(int);
        return (bytesRegistro + bytesNroElem + bytesMaxLista);
}